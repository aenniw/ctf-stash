#### Challenge:

[RSA](./output.txt ":ignore") strikes strikes strikes again again again! [Source](./rsa.py ":ignore")

---

#### Solution:

We know `N`, `e`, `C` and especially `Phi`, it is trivial RSA challenge:

```python
#!/usr/bin/env python

import gmpy2
from gmpy2 import mpz

N = 133075794736862400686388110598570266808714052683651232655122797445099216964925703530068957607358890220696254013415564497625510160656547477386290353341301388957868030883484367150794172590602260618953020322190415128204088685449855108061423638905602604314199002557585876080719068735072138975699738144061697925373
e = 65537
C = 42999486939739078417543300759928045769347425010481921402117654240134870338470114310074441997014418414023223148236139895795053257877203574091454937566637813901960299427919263842462481370908334316720948794826158725807235252653149450622143783560995967869958852519888842457531188064386890082072803961804464549309
Phi = 133075794736862400686388110598570266808714052683651232655122797445099216964925703530068957607358890220696254013415564497625510160656547477386290353341301365877872031151018140890962539358215097403168452396402116271802269636497626498820406125901329433708704273662567430256232652048920492894069126553095462130720

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b%a,a)
    return (g, x - (b//a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('No modular inverse')
    return x%m

d = modinv(e, Phi)

plain=gmpy2.powmod(C,d,N)


def convert_decimal_num_to_ascii_str(decimal_number):
    # Slice string to remove leading `0x`
    hex_string = hex(decimal_number)[2:]

    # Convert to bytes object
    bytes_object = bytes.fromhex(hex_string)

    # Convert to ASCII string
    ascii_string = bytes_object.decode("ASCII")
    return ascii_string

print(convert_decimal_num_to_ascii_str(plain))
```

---

<details><summary>FLAG:</summary>

```
actf{just_kidding_this_algorithm_wasnt_actually_randomly_sampled}
```

</details>
<br/>
